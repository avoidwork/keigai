{"name":"keigai","tagline":"Lightweight data store library featuring two way binding & 1-n views","body":"# keigai\r\n\r\nkeigai is a lightweight data store library featuring two way binding, 1-n reactive views, MVCC inspired versioning & API abstraction.\r\n\r\nkeigai has no dependencies, and offers a pluggable data store solution for any architecture by using a pub/sub (observer) paradigm for external hooks into UIs, and other work flows.\r\n\r\n## API\r\n\r\nFull API documentation is included, and available at http://api.keigai.io\r\n\r\n### filter (target, list, filters[, debounce])\r\nReturns a DataListFilter instance. DataListFilters provide a fast & easy way for the end user to refine the contents of a DataList or DataGrid. Wildcards are supported.\r\n\r\n### grid (target, store, fields[, sortable, options, filtered, debounce])\r\nReturns a DataGrid instance. DataGrids combine DataStores, DataLists, & DataListFilters into fast & responsive tabular representations.\r\n\r\n### list (target, store, template[, options])\r\nReturns a DataList instance. DataLists are the core visual representation of a DataStore, using \"handle bar\" style templates.\r\n\r\n### store ([data, options])\r\nReturns a DataStore instance. DataStores are in ram NoSQL databases, with many features found in SQL databases, such as JOINs, ORDER BYs, & WHERE clauses.\r\n\r\nDataStores can be wired to an API through the `setUri()` method, which hooks them into the feedback loop. If you \"set\" or \"delete\" a record, the operation doesn't complete until the API provides a \"success\" or \"failure\" response.\r\n\r\nDeferreds (Promises) are returned from methods that can \"go over the wire\", for easy handling of the asynchronous communication.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}